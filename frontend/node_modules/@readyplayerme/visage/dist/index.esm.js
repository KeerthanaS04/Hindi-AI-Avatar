import React, { useMemo, useEffect, useRef, useState, Suspense, useCallback, cloneElement } from 'react';
import { Environment as Environment$1, useBounds, PresentationControls, Bounds, ContactShadows } from '@react-three/drei';
import { Vector2, LinearFilter, Vector3, Euler, AnimationMixer, DirectionalLight, AmbientLight, SpotLight, TextureLoader } from 'three';
import { useFrame, useGraph, Canvas, useThree, useLoader } from '@react-three/fiber';
import { GLTFLoader, OrbitControls } from 'three-stdlib';
import { suspend } from 'suspend-react';

const environmentPresets = {
    hub: 'hub',
    sunset: 'sunset',
    dawn: 'dawn',
    night: 'night',
    warehouse: 'warehouse',
    forest: 'forest',
    apartment: 'apartment',
    studio: 'studio',
    city: 'city',
    park: 'park',
    lobby: 'lobby'
};
const getPresetEnvironmentMap = (preset) => `https://readyplayerme-assets.s3.amazonaws.com/environment/${preset}.hdr`;

const Environment = ({ environment }) => {
    const config = useMemo(() => {
        const isStaticPreset = environment in environmentPresets;
        const files = isStaticPreset ? getPresetEnvironmentMap(environment) : environment;
        return {
            files
        };
    }, [environment]);
    return React.createElement(Environment$1, { files: config.files });
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const validateGlbSource = (source) => {
    if (Array.isArray(source)) {
        return source.length > 0 && source.every(validateGlbSource);
    }
    if (typeof source === 'string') {
        const fileEndExpression = new RegExp(/(.glb|.glb[?].*)$/g);
        const uploadFileExpression = new RegExp(/^data:application\/octet-stream;base64,/g);
        const gltfModelExpression = new RegExp(/^data:model\/gltf-binary;base64,/g);
        return fileEndExpression.test(source) || uploadFileExpression.test(source) || gltfModelExpression.test(source);
    }
    if (source instanceof Blob) {
        return source.type === 'model/gltf-binary';
    }
    return false;
};
const isValidGlbFormat = (source) => {
    const isValid = validateGlbSource(source);
    if (!isValid) {
        console.warn('Provided GLB is invalid. Check docs for supported formats: https://github.com/readyplayerme/visage');
    }
    return isValid;
};
const clamp = (value, max, min) => Math.min(Math.max(min, value), max);
const lerp = (start, end, time = 0.05) => start * (1 - time) + end * time;
/**
 * Avoid texture pixelation and add depth effect.
 */
const normaliseMaterialsConfig = (materials) => {
    Object.values(materials).forEach((material) => {
        const mat = material;
        if (mat.map) {
            mat.map.minFilter = LinearFilter;
            mat.depthWrite = true;
        }
    });
};
/**
 * Avatar head movement relative to cursor.
 * When the model isn't a standard Ready Player Me avatar, the head movement won't take effect.
 */
const useHeadMovement = ({ nodes, isHalfBody = false, distance = 2, activeRotation = 0.2, rotationMargin = new Vector2(5, 10), enabled = false }) => {
    const rad = Math.PI / 180;
    const currentPos = new Vector2(0, 0);
    const targetPos = new Vector2(0, 0);
    const activeDistance = distance - (isHalfBody ? 1 : 0);
    const eyeRotationOffsetX = isHalfBody ? 90 * rad : 0;
    const neckBoneRotationOffsetX = (isHalfBody ? -5 : 10) * rad;
    const mapRange = (value, inMin, inMax, outMin, outMax) => ((clamp(value, inMax, inMin) - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
    useFrame((state) => {
        if (!enabled || !nodes.Neck || !nodes.Head || !nodes.RightEye || !nodes.LeftEye) {
            return;
        }
        const cameraToHeadDistance = state.camera.position.distanceTo(nodes.Head.position);
        const cameraRotation = Math.abs(state.camera.rotation.z);
        if (cameraToHeadDistance < activeDistance && cameraRotation < activeRotation) {
            targetPos.x = mapRange(state.mouse.y, -0.5, 1, rotationMargin.x * rad, -rotationMargin.x * rad);
            targetPos.y = mapRange(state.mouse.x, -0.5, 0.5, -rotationMargin.y * rad, rotationMargin.y * rad);
        }
        else {
            targetPos.set(0, 0);
        }
        currentPos.x = lerp(currentPos.x, targetPos.x);
        currentPos.y = lerp(currentPos.y, targetPos.y);
        /* eslint-disable no-param-reassign */
        nodes.Neck.rotation.x = currentPos.x + neckBoneRotationOffsetX;
        nodes.Neck.rotation.y = currentPos.y;
        nodes.Head.rotation.x = currentPos.x;
        nodes.Head.rotation.y = currentPos.y;
        nodes.RightEye.rotation.x = currentPos.x - eyeRotationOffsetX;
        nodes.LeftEye.rotation.x = currentPos.x - eyeRotationOffsetX;
        if (isHalfBody) {
            nodes.RightEye.rotation.z = currentPos.y * 2 + Math.PI;
            nodes.LeftEye.rotation.z = currentPos.y * 2 + Math.PI;
        }
        else {
            nodes.RightEye.rotation.y = currentPos.y * 2;
            nodes.LeftEye.rotation.y = currentPos.y * 2;
        }
    });
};
/**
 * Transfers Bone positions from source to target.
 * @param targetNodes {object} - object that will be mutated
 * @param sourceNodes {object} - object that will be used as reference
 */
const mutatePose = (targetNodes, sourceNodes) => {
    if (targetNodes && sourceNodes) {
        Object.keys(targetNodes).forEach((key) => {
            if (targetNodes[key].type === 'Bone' && sourceNodes[key]) {
                /* eslint-disable no-param-reassign */
                const pos = sourceNodes[key].position;
                targetNodes[key].position.set(pos.x, pos.y, pos.z);
                const rot = sourceNodes[key].rotation;
                targetNodes[key].rotation.set(rot.x, rot.y, rot.z);
            }
        });
    }
};
const useEmotion = (nodes, emotion) => {
    // @ts-ignore
    const meshes = Object.values(nodes).filter((item) => item === null || item === void 0 ? void 0 : item.morphTargetInfluences);
    const resetEmotions = (resetMeshes) => {
        resetMeshes.forEach((mesh) => {
            var _a;
            (_a = mesh === null || mesh === void 0 ? void 0 : mesh.morphTargetInfluences) === null || _a === void 0 ? void 0 : _a.forEach((_, index) => {
                mesh.morphTargetInfluences[index] = 0;
            });
        });
    };
    useFrame(() => {
        if (emotion) {
            resetEmotions(meshes);
            meshes.forEach((mesh) => {
                Object.entries(emotion).forEach(([shape, value]) => {
                    var _a;
                    const shapeId = (_a = mesh.morphTargetDictionary) === null || _a === void 0 ? void 0 : _a[shape];
                    if (shapeId) {
                        mesh.morphTargetInfluences[shapeId] = value;
                    }
                });
            });
        }
        else {
            resetEmotions(meshes);
        }
    });
};
const useGltfLoader = (source) => suspend(() => __awaiter(void 0, void 0, void 0, function* () {
    const loader = new GLTFLoader();
    if (source instanceof Blob) {
        const buffer = yield source.arrayBuffer();
        return (yield loader.parseAsync(buffer, ''));
    }
    const gltf = yield loader.loadAsync(source);
    return gltf;
}), [source]);
class Transform {
    constructor() {
        this.scale = new Vector3(1, 1, 1);
        this.rotation = new Euler(0, 0, 0);
        this.position = new Vector3(0, 0, 0);
    }
}
/**
 * Builds a fallback model for given nodes.
 * Useful for displaying as the suspense fallback object.
 */
function buildFallback(nodes, transform = new Transform()) {
    return (React.createElement("group", null, Object.keys(nodes).map((key) => {
        const node = nodes[key];
        if (node.type === 'SkinnedMesh') {
            return (React.createElement("skinnedMesh", { castShadow: true, receiveShadow: true, key: node.name, scale: transform.scale, position: transform.position, rotation: transform.rotation, geometry: node.geometry, material: node.material, skeleton: node.skeleton, morphTargetInfluences: node.morphTargetInfluences || [] }));
        }
        if (node.type === 'Mesh') {
            return (React.createElement("mesh", { castShadow: true, receiveShadow: true, key: node.name, scale: transform.scale, position: transform.position, rotation: transform.rotation, geometry: node.geometry, material: node.material, morphTargetInfluences: node.morphTargetInfluences || [] }));
        }
        return null;
    })));
}
const useFallback = (nodes, setter) => useEffect(() => {
    if (typeof setter === 'function') {
        setter(buildFallback(nodes));
    }
}, [setter, nodes]);
const triggerCallback = (callback) => {
    if (typeof callback === 'function') {
        callback();
    }
};

const Model = ({ scene, scale = 1, modelRef, onLoaded }) => {
    const { materials } = useGraph(scene);
    normaliseMaterialsConfig(materials);
    scene.traverse((object) => {
        const node = object;
        if (node.isMesh) {
            node.castShadow = true;
        }
        if (node.type === 'SkinnedMesh') {
            node.receiveShadow = true;
        }
    });
    useEffect(() => triggerCallback(onLoaded), [scene, materials, onLoaded]);
    return (React.createElement("group", { ref: modelRef, dispose: null, rotation: [0, 0, 0] },
        React.createElement("primitive", { object: scene, scale: scale })));
};

const FloatingModel = ({ modelSrc, scale = 1.0, onLoaded }) => {
    const ref = useRef();
    const { scene } = useGltfLoader(modelSrc);
    useFrame((state) => {
        const t = state.clock.getElapsedTime();
        if (ref === null || ref === void 0 ? void 0 : ref.current) {
            ref.current.rotation.y = Math.sin(t / 2) / 8;
            ref.current.position.y = (1 + Math.sin(t / 1.5)) / -9;
        }
    });
    return React.createElement(Model, { modelRef: ref, scale: scale, scene: scene, onLoaded: onLoaded });
};

/**
 * Contains model to handle suspense fallback.
 */
const FloatingModelContainer = (props) => {
    /* eslint-disable-next-line react/jsx-no-useless-fragment */
    const [fallback, setFallback] = useState(React.createElement(React.Fragment, null));
    return (React.createElement(Suspense, { fallback: fallback },
        React.createElement(FloatingModel, Object.assign({}, props, { setModelFallback: setFallback }))));
};

const StaticModel = ({ modelSrc, modelRef, scale = 1, setModelFallback, onLoaded, emotion }) => {
    const { scene } = useGltfLoader(modelSrc);
    const { nodes } = useGraph(scene);
    useEmotion(nodes, emotion);
    useFallback(nodes, setModelFallback);
    return React.createElement(Model, { modelRef: modelRef, scene: scene, scale: scale, onLoaded: onLoaded });
};

/**
 * Contains model to handle suspense fallback.
 */
const StaticModelContainer = (props) => {
    /* eslint-disable-next-line react/jsx-no-useless-fragment */
    const [fallback, setFallback] = useState(React.createElement(React.Fragment, null));
    return (React.createElement(Suspense, { fallback: fallback },
        React.createElement(StaticModel, Object.assign({ setModelFallback: setFallback }, props))));
};

const BoundsModelContainer = ({ modelSrc, children, fit, onLoaded }) => {
    const bounds = useBounds();
    const [fallback, setFallback] = useState(React.createElement(React.Fragment, null));
    const onChildLoaded = useCallback(() => {
        if (fit) {
            bounds.refresh().clip().fit();
        }
        triggerCallback(onLoaded);
    }, [bounds, fit]);
    const childModel = useMemo(() => React.Children.map(children, (child) => cloneElement(child, { setModelFallback: setFallback, onLoaded: onChildLoaded })), [modelSrc, children, onChildLoaded]);
    useEffect(() => {
        if (fit) {
            bounds.refresh().clip().fit();
        }
    }, [modelSrc, fit, fallback]);
    return React.createElement(React.Fragment, null, childModel);
};

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$1 = ".BaseCanvas-module_base-canvas__Xjohd {\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n}";
var styles$1 = {"base-canvas":"BaseCanvas-module_base-canvas__Xjohd"};
styleInject(css_248z$1);

const BaseCanvas = ({ children = undefined, fov = 50, position = new Vector3(0, 0, 5), style, dpr = [1, 2], className }) => (React.createElement(Canvas, { className: `${styles$1['base-canvas']} ${className !== null && className !== void 0 ? className : ''}`, shadows: true, gl: { preserveDrawingBuffer: true }, dpr: dpr, camera: { fov, position }, resize: { scroll: true, debounce: { scroll: 50, resize: 0 } }, style: Object.assign({}, style) }, children));

const Capture = ({ trigger, settings, callBack }) => {
    const gl = useThree((state) => state.gl);
    const type = (settings === null || settings === void 0 ? void 0 : settings.type) || 'image/png';
    const quality = (settings === null || settings === void 0 ? void 0 : settings.quality) || 0.1;
    useEffect(() => {
        if (trigger) {
            const capture = gl.domElement.toDataURL(type, quality);
            callBack(capture);
        }
        /* eslint-disable-next-line react-hooks/exhaustive-deps */
    }, [trigger]);
    // eslint-disable-next-line react/jsx-no-useless-fragment
    return React.createElement(React.Fragment, null);
};

/**
 * Interactive presentation of any GLTF (.glb) asset.
 */
const Exhibit = ({ modelSrc, scale = 1.0, environment = 'city', position, style, className, shadows = false, float = false, fit = false, capture, snap = false, lockVertical = false, onLoaded, onLoading }) => {
    const model = useMemo(() => {
        if (!isValidGlbFormat(modelSrc)) {
            return null;
        }
        if (!float) {
            return React.createElement(StaticModelContainer, { modelSrc: modelSrc, scale: scale });
        }
        return React.createElement(FloatingModelContainer, { modelSrc: modelSrc, scale: scale });
    }, [float, modelSrc, scale]);
    useEffect(() => triggerCallback(onLoading), [modelSrc, onLoading]);
    return (React.createElement(BaseCanvas, { position: position, style: style, className: className },
        React.createElement(Suspense, { fallback: null },
            React.createElement("ambientLight", { intensity: 0.5 }),
            React.createElement("spotLight", { position: [10, 10, 10], angle: 0.15, penumbra: 1, "shadow-mapSize": [512, 512], castShadow: true }),
            React.createElement(PresentationControls, { global: true, config: { mass: 2, tension: 500 }, snap: snap, rotation: [0, -0.3, 0], polar: lockVertical ? [0, 0] : [-Math.PI / 3, Math.PI / 3], azimuth: [-Infinity, Infinity] }, model && (React.createElement(Bounds, { fit: fit, clip: fit, observe: fit },
                React.createElement(BoundsModelContainer, { modelSrc: modelSrc, fit: fit, onLoaded: onLoaded }, model)))),
            shadows && (React.createElement(ContactShadows, { "rotation-x": Math.PI / 2, position: [0, -1.0, 0], opacity: 0.75, width: 10, height: 10, blur: 2.6, far: 2 })),
            React.createElement(Environment, { environment: environment })),
        capture && React.createElement(Capture, Object.assign({}, capture))));
};

let currentRotation$1 = 0;
const AnimationModel = ({ modelSrc, animationSrc, rotation = 20 * (Math.PI / 180), scale = 1, idleRotation = false, setModelFallback, onLoaded, headMovement = false }) => {
    const ref = useRef();
    const { scene } = useGltfLoader(modelSrc);
    const { nodes } = useGraph(scene);
    const animationSource = useGltfLoader(animationSrc);
    const animationMixer = useMemo(() => {
        const mixer = new AnimationMixer(nodes.Armature);
        mixer.clipAction(animationSource.animations[0]).play();
        mixer.update(0);
        return mixer;
    }, [animationSource.animations, nodes.Armature]);
    useFrame((state, delta) => {
        animationMixer === null || animationMixer === void 0 ? void 0 : animationMixer.update(delta);
        if (!idleRotation) {
            return;
        }
        if (ref === null || ref === void 0 ? void 0 : ref.current) {
            currentRotation$1 += delta * 0.2;
            ref.current.rotation.y = rotation + Math.sin(currentRotation$1) / 3;
        }
    });
    useHeadMovement({ nodes, enabled: headMovement });
    useFallback(nodes, setModelFallback);
    return React.createElement(Model, { modelRef: ref, scene: scene, scale: scale, onLoaded: onLoaded });
};

/**
 * Contains model to handle suspense fallback.
 */
const AnimationModelContainer = (props) => {
    /* eslint-disable-next-line react/jsx-no-useless-fragment */
    const [fallback, setFallback] = useState(React.createElement(React.Fragment, null));
    return (React.createElement(Suspense, { fallback: fallback },
        React.createElement(AnimationModel, Object.assign({ setModelFallback: setFallback }, props))));
};

let currentRotation = 0;
const HalfBodyModel = ({ modelSrc, scale = 1, rotation = 20 * (Math.PI / 180), idleRotation = false, emotion, setModelFallback, onLoaded, headMovement = false }) => {
    const ref = useRef();
    const { scene } = useGltfLoader(modelSrc);
    const { nodes } = useGraph(scene);
    scene.traverse((object) => {
        const node = object;
        if (node.name === 'Wolf3D_Hands') {
            node.visible = false;
        }
        if (node.name === 'RightHand') {
            node.position.set(0, -2, 0);
        }
        if (node.name === 'LeftHand') {
            node.position.set(0, -2, 0);
        }
    });
    useFrame((state, delta) => {
        if (!idleRotation) {
            return;
        }
        if (ref === null || ref === void 0 ? void 0 : ref.current) {
            currentRotation += delta * 0.2;
            ref.current.rotation.y = rotation + Math.sin(currentRotation) / 3;
        }
    });
    useHeadMovement({ nodes, isHalfBody: true, enabled: headMovement });
    useEmotion(nodes, emotion);
    useFallback(nodes, setModelFallback);
    return React.createElement(Model, { modelRef: ref, scene: scene, scale: scale, onLoaded: onLoaded });
};

/**
 * Contains model to handle suspense fallback.
 */
const HalfBodyModelContainer = (props) => {
    /* eslint-disable-next-line react/jsx-no-useless-fragment */
    const [fallback, setFallback] = useState(React.createElement(React.Fragment, null));
    return (React.createElement(Suspense, { fallback: fallback },
        React.createElement(HalfBodyModel, Object.assign({ setModelFallback: setFallback }, props))));
};

const PoseModel = ({ modelSrc, poseSrc, modelRef, scale = 1, emotion, setModelFallback, onLoaded }) => {
    const { scene } = useGltfLoader(modelSrc);
    const { nodes } = useGraph(scene);
    const pose = useGltfLoader(poseSrc);
    const { nodes: sourceNodes } = useGraph(pose.scene);
    mutatePose(nodes, sourceNodes);
    useEmotion(nodes, emotion);
    useFallback(nodes, setModelFallback);
    return React.createElement(Model, { modelRef: modelRef, scene: scene, scale: scale, onLoaded: onLoaded });
};

/**
 * Contains model to handle suspense fallback.
 */
const PoseModelContainer = (props) => {
    /* eslint-disable-next-line react/jsx-no-useless-fragment */
    const [fallback, setFallback] = useState(React.createElement(React.Fragment, null));
    return (React.createElement(Suspense, { fallback: fallback },
        React.createElement(PoseModel, Object.assign({ setModelFallback: setFallback }, props))));
};

let controls;
let progress = Number.POSITIVE_INFINITY;
const updateCameraFocus = (camera, delta, target) => {
    if (target && progress <= 1) {
        camera.position.setX(lerp(camera.position.x, target.x, progress));
        camera.position.setZ(lerp(camera.position.z, target.z, progress));
        progress += delta;
    }
};
const updateCameraTarget = (camera, target, minDistance, maxDistance) => {
    if (controls) {
        let distance = controls.target.distanceTo(camera.position);
        distance = clamp(distance, maxDistance, minDistance);
        const pivot = (distance - minDistance) / (maxDistance - minDistance);
        controls.target.set(0, target - 0.6 * pivot, 0);
    }
};
const CameraLighting = ({ cameraTarget, cameraInitialDistance, cameraZoomTarget, headScale = 1, ambientLightColor, ambientLightIntensity, dirLightPosition, dirLightColor, dirLightIntensity, spotLightPosition, spotLightColor, spotLightAngle, spotLightIntensity, controlsMinDistance = 0.4, controlsMaxDistance = 2.5, updateCameraTargetOnZoom = false }) => {
    const cameraZoomTargetRef = useRef(cameraZoomTarget);
    const { camera, gl, scene } = useThree();
    const fallbackCameraTarget = cameraTarget || 1.475 + headScale / 10;
    const headScaleAdjustedMinDistance = controlsMinDistance + headScale / 10;
    useEffect(() => {
        var _a, _b, _c;
        if (((_a = cameraZoomTargetRef.current) === null || _a === void 0 ? void 0 : _a.x) !== (cameraZoomTarget === null || cameraZoomTarget === void 0 ? void 0 : cameraZoomTarget.x) ||
            ((_b = cameraZoomTargetRef.current) === null || _b === void 0 ? void 0 : _b.y) !== (cameraZoomTarget === null || cameraZoomTarget === void 0 ? void 0 : cameraZoomTarget.y) ||
            ((_c = cameraZoomTargetRef.current) === null || _c === void 0 ? void 0 : _c.z) !== (cameraZoomTarget === null || cameraZoomTarget === void 0 ? void 0 : cameraZoomTarget.z)) {
            cameraZoomTargetRef.current = cameraZoomTarget;
            progress = 0;
        }
        controls = new OrbitControls(camera, gl.domElement);
        controls.enablePan = false;
        controls.minDistance = headScaleAdjustedMinDistance;
        controls.maxDistance = controlsMaxDistance;
        controls.minPolarAngle = 1.4;
        controls.maxPolarAngle = 1.4;
        controls.target.set(0, fallbackCameraTarget, 0);
        controls.update();
        // TODO: Look for a better distance initialiser, without progress value check it conflicts with cameraZoomTarget which also can update camera position.z
        if (cameraInitialDistance && progress === Number.POSITIVE_INFINITY) {
            camera.position.z = cameraInitialDistance;
            controls.update();
        }
        return () => {
            controls.dispose();
        };
    }, [
        cameraInitialDistance,
        camera,
        controlsMinDistance,
        controlsMaxDistance,
        fallbackCameraTarget,
        gl.domElement,
        headScaleAdjustedMinDistance,
        cameraZoomTarget
    ]);
    useEffect(() => {
        if (!scene.getObjectByName('back-highlight')) {
            const dirLight = new DirectionalLight(dirLightColor, dirLightIntensity);
            dirLight.name = 'back-highlight';
            dirLight.position.set(dirLightPosition.x, dirLightPosition.y, dirLightPosition.z);
            dirLight.castShadow = true;
            dirLight.shadow.bias = -0.0001;
            dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.blurSamples = 100;
            const ambientLight = new AmbientLight(ambientLightColor, ambientLightIntensity);
            ambientLight.name = 'ambient-light';
            ambientLight.position.set(0, 0, 0);
            const spotLight = new SpotLight(spotLightColor, spotLightIntensity, 0, spotLightAngle, 0, 1);
            spotLight.name = 'spot-light';
            spotLight.position.set(spotLightPosition.x, spotLightPosition.y, spotLightPosition.z);
            camera.add(ambientLight);
            camera.add(spotLight);
            camera.add(dirLight);
            scene.add(camera);
        }
        else {
            const dirLight = scene.getObjectByName('back-highlight');
            dirLight.color.set(dirLightColor);
            dirLight.intensity = dirLightIntensity;
            dirLight.position.set(dirLightPosition.x, dirLightPosition.y, dirLightPosition.z);
            const ambientLight = scene.getObjectByName('ambient-light');
            ambientLight.color.set(ambientLightColor);
            ambientLight.intensity = ambientLightIntensity;
            const spotLight = scene.getObjectByName('spot-light');
            spotLight.color.set(spotLightColor);
            spotLight.intensity = spotLightIntensity;
            spotLight.angle = spotLightAngle;
            spotLight.position.set(spotLightPosition.x, spotLightPosition.y, spotLightPosition.z);
        }
    }, [
        ambientLightColor,
        ambientLightIntensity,
        dirLightPosition,
        dirLightColor,
        dirLightIntensity,
        spotLightPosition,
        spotLightColor,
        spotLightIntensity,
        spotLightAngle,
        camera,
        scene
    ]);
    useFrame((_, delta) => {
        if (updateCameraTargetOnZoom) {
            updateCameraTarget(camera, fallbackCameraTarget, headScaleAdjustedMinDistance, controlsMaxDistance);
        }
        updateCameraFocus(camera, delta, cameraZoomTarget);
        controls.update();
    });
    return null;
};

const Box = (_a) => {
    var { src = '' } = _a, baseProps = __rest(_a, ["src"]);
    const ref = useRef();
    const texture = useLoader(TextureLoader, src);
    return (React.createElement("mesh", Object.assign({ ref: ref, castShadow: true, receiveShadow: true }, baseProps),
        React.createElement("boxBufferGeometry", null),
        React.createElement("meshPhysicalMaterial", { map: texture })));
};

const Shadow = () => (React.createElement("group", { position: [0, 0, 0] },
    React.createElement("mesh", { key: "shadow-catcher", receiveShadow: true, position: [0, 0, 0], "rotation-x": -Math.PI / 2 },
        React.createElement("planeBufferGeometry", { attach: "geometry", args: [5, 5] }),
        React.createElement("shadowMaterial", { attach: "material", transparent: true, opacity: 0.2 }))));

var css_248z = ".Loader-module_loader__Ukoov {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  height: 100%;\n  width: 100%;\n}\n\n.Loader-module_dots__KfhUo {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.Loader-module_dot__qTWRh {\n  background-color: #ececec;\n  width: 8px;\n  height: 8px;\n  margin: 2px;\n  border-radius: 100%;\n  display: inline-block;\n}\n.Loader-module_dot__qTWRh:nth-child(1) {\n  animation: 0.75s cubic-bezier(0.2, 0.68, 0.18, 1.08) 0.12s infinite normal both running Loader-module_glowing__nwo3q;\n}\n.Loader-module_dot__qTWRh:nth-child(2) {\n  animation: 0.75s cubic-bezier(0.2, 0.68, 0.18, 1.08) 0.24s infinite normal both running Loader-module_glowing__nwo3q;\n}\n.Loader-module_dot__qTWRh:nth-child(3) {\n  animation: 0.75s cubic-bezier(0.2, 0.68, 0.18, 1.08) 0.36s infinite normal both running Loader-module_glowing__nwo3q;\n}\n\n@keyframes Loader-module_glowing__nwo3q {\n  0% {\n    transform: scale(1);\n    opacity: 1;\n  }\n  45% {\n    transform: scale(0.1);\n    opacity: 0.7;\n  }\n  80% {\n    transform: scale(1);\n    opacity: 1;\n  }\n}";
var styles = {"loader":"Loader-module_loader__Ukoov","dots":"Loader-module_dots__KfhUo","dot":"Loader-module_dot__qTWRh","glowing":"Loader-module_glowing__nwo3q"};
styleInject(css_248z);

const Loader = () => (React.createElement("div", { className: styles.loader },
    React.createElement("div", { className: styles.dots }, [1, 2, 3].map((it) => (React.createElement("div", { key: it, className: styles.dot }))))));

const CAMERA = {
    TARGET: {
        FULL_BODY: {
            MALE: 1.65,
            FEMALE: 1.55
        },
        HALF_BODY: 0.6
    },
    INITIAL_DISTANCE: {
        FULL_BODY: 0.4,
        HALF_BODY: 0.5
    },
    CONTROLS: {
        FULL_BODY: {
            MIN_DISTANCE: 0.5,
            MAX_DISTANCE: 2.5,
            ZOOM_TARGET: new Vector3(-0.11, 0, 0.48)
        },
        HALF_BODY: {
            MIN_DISTANCE: 0.4,
            MAX_DISTANCE: 1.4,
            ZOOM_TARGET: new Vector3(-0.15, 0, 0.55)
        }
    }
};
/**
 * Interactive avatar presentation with zooming and horizontal rotation controls.
 * Optimised for full-body and half-body avatars.
 */
const Avatar = ({ modelSrc, animationSrc = undefined, poseSrc = undefined, environment = 'city', halfBody = false, shadows = false, scale = 1, ambientLightColor = '#fff5b6', ambientLightIntensity = 0.25, dirLightPosition = new Vector3(-3, 5, -5), dirLightColor = '#002aff', dirLightIntensity = 5, spotLightPosition = new Vector3(12, 10, 7.5), spotLightColor = '#fff5b6', spotLightAngle = 0.314, spotLightIntensity = 1, cameraTarget = CAMERA.TARGET.FULL_BODY.MALE, cameraInitialDistance = CAMERA.INITIAL_DISTANCE.FULL_BODY, style, emotion, idleRotation = false, capture, background, loader, onLoaded, onLoading, dpr, className, headMovement = false, cameraZoomTarget = CAMERA.CONTROLS.FULL_BODY.ZOOM_TARGET }) => {
    const AvatarModel = useMemo(() => {
        if (!isValidGlbFormat(modelSrc)) {
            return null;
        }
        if (!!animationSrc && !halfBody && isValidGlbFormat(animationSrc)) {
            return (React.createElement(AnimationModelContainer, { modelSrc: modelSrc, animationSrc: animationSrc, scale: scale, idleRotation: idleRotation, onLoaded: onLoaded, headMovement: headMovement }));
        }
        if (halfBody) {
            return (React.createElement(HalfBodyModelContainer, { emotion: emotion, modelSrc: modelSrc, scale: scale, idleRotation: idleRotation, onLoaded: onLoaded, headMovement: headMovement }));
        }
        if (isValidGlbFormat(poseSrc)) {
            return React.createElement(PoseModelContainer, { emotion: emotion, modelSrc: modelSrc, scale: scale, poseSrc: poseSrc, onLoaded: onLoaded });
        }
        return React.createElement(StaticModelContainer, { modelSrc: modelSrc, scale: scale, onLoaded: onLoaded, emotion: emotion });
    }, [halfBody, animationSrc, modelSrc, scale, poseSrc, idleRotation, emotion, onLoaded, headMovement]);
    useEffect(() => triggerCallback(onLoading), [modelSrc, animationSrc, onLoading]);
    return (React.createElement(Suspense, { fallback: loader !== null && loader !== void 0 ? loader : React.createElement(Loader, null) },
        React.createElement(BaseCanvas, { position: new Vector3(0, 0, 3), fov: 50, style: style, dpr: dpr, className: className },
            React.createElement(Environment, { environment: environment }),
            React.createElement(CameraLighting, { cameraTarget: cameraTarget, cameraInitialDistance: cameraInitialDistance, cameraZoomTarget: cameraZoomTarget, ambientLightColor: ambientLightColor, ambientLightIntensity: ambientLightIntensity, dirLightPosition: dirLightPosition, dirLightColor: dirLightColor, dirLightIntensity: dirLightIntensity, spotLightPosition: spotLightPosition, spotLightColor: spotLightColor, spotLightAngle: spotLightAngle, spotLightIntensity: spotLightIntensity, controlsMinDistance: halfBody ? CAMERA.CONTROLS.HALF_BODY.MIN_DISTANCE : CAMERA.CONTROLS.FULL_BODY.MIN_DISTANCE, controlsMaxDistance: halfBody ? CAMERA.CONTROLS.HALF_BODY.MAX_DISTANCE : CAMERA.CONTROLS.FULL_BODY.MAX_DISTANCE, updateCameraTargetOnZoom: !halfBody }),
            AvatarModel,
            shadows && React.createElement(Shadow, null),
            (background === null || background === void 0 ? void 0 : background.src) && React.createElement(Box, Object.assign({}, background)),
            capture && React.createElement(Capture, Object.assign({}, capture)))));
};

export { AnimationModelContainer as AnimationModel, Avatar, CAMERA, Exhibit, FloatingModelContainer as FloatingModel, HalfBodyModelContainer as HalfBodyModel, PoseModelContainer as PoseModel, StaticModelContainer as StaticModel };
